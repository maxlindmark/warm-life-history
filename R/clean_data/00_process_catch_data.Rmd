---
title: "Clean catch data"
author: "Max Lindmark & Malin Karlsson"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    df_print: paged
  pdf_document: default
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
---

```{r setup, include = FALSE, cache=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 12,
  fig.asp = 0.618,
  fig.align ='center'
)
```

Read in catch data, clean, filter and process. FM data, unlike the BT data, comes in data files which correspond to the tabs in the spreadsheet: FM09_alla_grundutrdag_combinedbyAG_190916. They all have different layout so I will clean them separately... 

Load libraries
```{r load libraries}
library(tidyverse)
library(tidylog)
library(RColorBrewer)
library(patchwork)
sessionInfo() 
```

## Forsmark
### 1983-1986
```{r read & process FORSMARK (REFERENCE) data sets 1983-1986}
# Need to set fileEncoding here, else error: "invalid multibyte string 18"
df83 <- read.csv("data/raw/Catch_data_FM09__1983-86_190916.csv", sep = ";", fileEncoding = "latin1")

# Tidy data. Remove unnecessary columns
df83 <- df83 %>%
  filter(Art == "ABBO", Årtal < 2004) %>%
  rename(year = Årtal, week = Vecka, day = Dag, effort = Ansträngning, species = Art,
         weight = Vikt, n = Antal) %>%
  select(-c(Vtn.stånd, VindRiktn.I, VindSt.I, Vind_upp_rikn, VindSt.Upp, Ström_I_rikn,
            Ström_upp_rikn, Salthalt_I_yta, Salthalt_I_botten, Salthalt_upp_yta, 
            Salthalt_upp_botten, Drift_i, Drift_u, Drift_dim, Siktdjup, Lufttryck_i,
            Lufttryck_upp, Sjuk_kontroll, X..))

# We would much rather prefer to have a column for each length, so that 1 row = observation.
dat83 <- df83 %>%
  gather(length, n2, c(X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12, X13, X14), na.rm = T)

head(df83)
head(dat83) # Now the data is in a long, tidy format. 

# Test it is correct:
subset(df83, year == 1983 & week == 30 & day == 2 & Stations_namn == "Asphällan")
subset(dat83, year == 1983 & week == 30 & day == 2 & Stations_namn == "Asphällan")

# Create a new empty column for numeric "length"
dat83$length_group <- as.numeric(substring(dat83$length, 2))

head(dat83)                            
str(dat83)

# Our n2 column tells us how many fish are in that size-group. We want one row for each observation!
# So we need to repeat that observation by n2.

# Now repeat
dat83 <- dat83[rep(seq(nrow(dat83)), dat83$n2),]
head(dat83, 50)

# Test it is correct:
df83 %>%
  filter(year == 1983 & week == 30 & day == 2 & Stations_namn == "Asphällan") %>% 
  arrange(n) %>% 
  as.data.frame()

dat83 %>%
  filter(year == 1983 & week == 30 & day == 2 & Stations_namn == "Asphällan") %>% 
  arrange(n) %>% 
  dplyr::select(-YtTmp.I, -YtTmp.Upp, -Störning, -TmpBtnU, -Sektion_namn, -Sektion,
                -Areanamn, -Position_N, -Position_E, -Provfiske, -Redskap) %>% 
  as.data.frame()
```  

### 1987-1990
```{r read & process FORSMARK (REFERENCE) data sets 1987-1990}
df87 <- read.csv("data/raw/Catch_data_FM09__1987-90_190916.csv", sep = ";", fileEncoding = "latin1")

# Tidy data. Remove unnecessary columns
df87 <- df87 %>%
  filter(Art == "ABBO", Årtal < 2004) %>%
  rename(year = Årtal, week = Vecka, day = Dag, effort = Ansträngning, species = Art,
         weight = Vikt, n = Antal) %>%
  select(-c(Vtn.stånd, VindRiktn.I, VindSt.I, Vind_upp_rikn, VindSt.Upp, Ström_I_rikn,
            Ström_upp_rikn, Salthalt_I_yta, Salthalt_I_botten, Salthalt_upp_yta, 
            Salthalt_upp_botten, Drift_i, Drift_u, Drift_dim, Siktdjup, Lufttryck_i,
            Lufttryck_upp, Sjuk_kontroll, X..))

# Convert to long data frame
# Now the X-columns will be rows AND you will get a new column that takes the old "colmn" value and put that
# in the new column n2. 
dat87 <- df87 %>%
  gather(length, n2, c(X6, X9, X11, X14, X16, X19, X21, X24, X26, X29, X31, X34, X36, X39,
                       X41, X44, X46, X49, X51, X56, X59, X61, X64, X71), na.rm = T)

# Test it is correct:
subset(df87, year == 1987 & week == 32 & day == 2 & Stations_namn == "Asphällan")
subset(dat87, year == 1987 & week == 32 & day == 2 & Stations_namn == "Asphällan")

# Create a new empty column for numeric "length"
dat87$length_group <- as.numeric(substring(dat87$length, 2))

# Our n2 column tells us how many fish are in that size-group. We want one row for each observation!
# So we need to repeat that observation by n2.
dat87 <- dat87[rep(seq(nrow(dat87)), dat87$n2),]
head(dat87, 50)

# Test it is correct:
df87 %>%
  filter(year == 1987 & week == 32 & day == 2 & Stations_namn == "Asphällan") %>% 
  arrange(n) %>% 
  as.data.frame()

dat87 %>%
  filter(year == 1987 & week == 32 & day == 2 & Stations_namn == "Asphällan") %>% 
  arrange(n) %>% 
  dplyr::select(-YtTmp.I, -YtTmp.Upp, -Störning, -TmpBtnU, -Sektion_namn, -Sektion,
                -Areanamn, -Position_N, -Position_E, -Provfiske, -Redskap) %>% 
  as.data.frame()
```

### 1991-2000
```{r read & process FORSMARK (REFERENCE) data sets 1991-2000}
df91 <- read.csv("data/raw/Catch_data_FM09__1991-00_190916.csv", sep = ";", fileEncoding = "latin1")

# Tidy data. Remove unnecessary columns
df91 <- df91 %>%
  filter(Art == "ABBO", Årtal < 2004) %>%
  rename(year = Årtal, week = Vecka, day = Dag, effort = Ansträngning, species = Art,
         weight = Vikt, n = Antal) %>%
  select(-c(Vtn.stånd, VindRiktn.I, VindSt.I, Vind_upp_rikn, VindSt.Upp, Ström_I_rikn,
            Ström_upp_rikn, Salthalt_I_yta, Salthalt_I_botten, Salthalt_upp_yta, 
            Salthalt_upp_botten, Drift_i, Drift_u, Drift_dim, Siktdjup, Lufttryck_i,
            Lufttryck_upp, Sjuk_kontroll))

# Go from wide to long format
dat91 <- df91 %>%
  gather(length, n2, c(X9, X11, X14, X16, X19, X21, X24, X26, X29, X31, X34, X36, X39, X41, X44,
                       X46, X49, X51, X54, X56,X59, X61, X66, X69, X71, X76, X81, X101), na.rm = T)

# Test it is correct:
subset(df91, year == 1992 & week == 32 & day == 2 & Stations_namn == "Asphällan")
subset(dat91, year == 1992 & week == 32 & day == 2 & Stations_namn == "Asphällan")

# Create a new empty column for numeric "length"
dat91$length_group <- as.numeric(substring(dat91$length, 2))

# Our n2 column tells us how many fish are in that size-group. We want one row for each observation!
# So we need to repeat that observation by n2.
dat91 <- dat91[rep(seq(nrow(dat91)), dat91$n2),]
head(dat91, 50)

# Test it is correct:
df91 %>%
  filter(year == 1992 & week == 32 & day == 2 & Stations_namn == "Asphällan") %>% 
  arrange(n) %>% 
  as.data.frame()

dat91 %>%
  filter(year == 1992 & week == 32 & day == 2 & Stations_namn == "Asphällan") %>% 
  arrange(n) %>% 
  dplyr::select(-YtTmp.I, -YtTmp.Upp, -Störning, -TmpBtnU, -Sektion_namn, -Sektion,
                -Areanamn, -Position_N, -Position_E, -Provfiske, -Redskap) %>% 
  as.data.frame()
```

### 2001-2004
```{r read & process FORSMARK (REFERENCE) data sets 2001-2004}
df01 <- read.csv("data/raw/Catch_data_FM09__2001-06_190916.csv", sep = ";", fileEncoding = "latin1")

# Tidy data. Remove unnecessary columns
df01 <- df01 %>%
  filter(Art == "ABBO", Årtal < 2004) %>%
  rename(year = Årtal, week = Vecka, day = Dag, effort = Ansträngning, species = Art,
         weight = Vikt, n = Antal) %>%
  select(-c(Vtn.stånd, VindRiktn.I, VindSt.I, Vind_upp_rikn, VindSt.Upp, Ström_I_rikn,
            Ström_upp_rikn, Salthalt_I_yta, Salthalt_I_botten, Salthalt_upp_yta, 
            Salthalt_upp_botten, Drift_i, Drift_u, Drift_dim, Siktdjup, Lufttryck_i,
            Lufttryck_upp, Sjuk_kontroll, X..))


# Go from wide to long format
dat01 <- df01 %>%
  gather(length, n2, c(X7, X9, X10, X11, X12, X13, X14, X15, X16, X17, X18, X19, X20, X21, X22, X23, X24, X25,
                       X26, X27, X28, X29, X30, X31, X32, X33, X34, X35, X36, X37, X38, X39, X40, X41, X42, X43,
                       X44, X45, X46, X47, X48, X49, X50, X51, X52, X55, X62, X65, X80, X83, X90), na.rm = T)

# Test it is correct:
subset(df01, year == 2002 & week == 32 & day == 2 & Stations_namn == "Asphällan")
subset(dat01, year == 2002 & week == 32 & day == 2 & Stations_namn == "Asphällan")

# Create a new empty column for numeric "length"
dat01$length_group <- as.numeric(substring(dat01$length, 2))

# Our n2 column tells us how many fish are in that size-group. We want one row for each observation!
# So we need to repeat that observation by n2.
dat01 <- dat01[rep(seq(nrow(dat01)), dat01$n2),]
head(dat01, 50)

# Test it is correct:
df01 %>%
  filter(year == 2002 & week == 32 & day == 2 & Stations_namn == "Asphällan") %>% 
  arrange(n) %>% 
  as.data.frame()

dat01 %>%
  filter(year == 2002 & week == 32 & day == 2 & Stations_namn == "Asphällan") %>% 
  arrange(n) %>% 
  dplyr::select(-YtTmp.I, -YtTmp.Upp, -Störning, -TmpBtnU, -Sektion_namn, -Sektion,
                -Areanamn, -Position_N, -Position_E, -Provfiske, -Redskap) %>% 
  as.data.frame()
```

Combine all FM (reference) data
```{r combine all FM data}
catch_FM <- rbind(dat83, dat87, dat91, dat01)

catch_FM <- catch_FM %>% filter(year > 1982 & year < 2004)

#** Apply further filters ============================================================
# Remove disturbance
catch_FM <- catch_FM %>% filter(Störning == 0)

# Full data
ggplot(catch_FM, aes(factor(week), fill = factor(day))) +
  facet_wrap(~year, scales = "free_y") +
  geom_bar() +
  scale_fill_brewer(palette="Set1", name = "Weekday") +
  theme_classic(base_size = 12) +
  ggtitle("Reference area")

# Filter autumn fishing?
sort(unique(catch_FM$week))

# This is not necessary because the data only contains autumn fishing! 

# Since BT data is filter for year > 1986 this has to be done here as well.
catch_FM <- catch_FM %>% filter(year > 1986)

# All nets have the same effort
unique(catch_FM$effort)
unique(catch_FM$week)
```

## Biotest (warm area)
```{r 1984-2004}
# Need to set fileEncoding here, else error: "invalid multibyte string 18"
df <- read.csv("data/raw/Catch_data_BT09_140507.csv", sep = ";", fileEncoding = "latin1")

# Tidy data. Remove unnecessary columns
df <- df %>%
  filter(Art == "ABBO", Årtal < 2004) %>%
  dplyr::rename(year = Årtal, week = Vecka, day = Dag, effort = Ansträngning,
                species = Art, weight = Vikt, n = Antal) %>%
  select(-c(Vtn.stånd, VindRiktn.I, VindSt.I, Vind_upp_rikn, VindSt.Upp, Ström_I_rikn,
            Ström_upp_rikn, Salthalt_I_yta, Salthalt_I_botten, Salthalt_upp_yta,
            Salthalt_upp_botten, Drift_i, Drift_u, Drift_dim, Siktdjup, Lufttryck_i,
            Lufttryck_upp, Sjuk_kontroll))

# Slightly cleaner but we have a problem: X1, X2... X9 are length.
# We would much rather prefer to have a column for each length, so that 1 row = observation.
# Luckily there is a super neat function in tidyr (part of the tidyverse) called "gather".
# What I whant to do is:

# 1. Give the new column names I want to create, e.g. "length" 
# 2. Specify which columns are moved and shuffled in these columns.
# These will be the current columns for unique lengths. So check the str() and the column number using names() of the data again 

# I will move columns 13:121 = the ones starting at x8 to x116

# Now the X-columns will be rows AND you will get a new column that takes the old "column"
# value and put that in the new column n2. DOUBLE CHECK!!
dat <- df %>%
  gather(length, n2, c(X8, X9, X10, X11, X12, X13, X14, X15, X16, X17, X18, X19, X20,
                       X21, X22, X23, X24, X25, X26, X27, X28, X29, X30, X31, X32, X33,
                       X34, X35, X36, X37, X38, X39, X40, X41, X42, X43, X44, X45, X46,
                       X47, X48, X49, X50, X51, X52, X53, X54, X55, X56, X57, X58, X59,
                       X60, X61, X62, X63, X64, X65, X66, X67, X68, X69, X70, X71, X72,
                       X73, X74, X75, X76, X77, X78, X79, X80, X81, X82, X84, X85, X86,
                       X87, X88, X89, X90, X91, X93, X94, X96, X97, X98, X99, X101, X103,
                       X104, X106, X109, X111, X114, X116), na.rm = T)

head(dat) # Now the data is in a long, tidy format. 
head(df)

# Test it is correct:
subset(df, year == 2003 & week == 19 & day == 4 & Stations_namn == "Malören")
subset(dat, year == 2003 & week == 19 & day == 4 & Stations_namn == "Malören")

# But "length" is not numeric but a character. Create a new empty column for numeric "length"
dat$length_group <- as.numeric(substring(dat$length, 2))

# Our n2 column tells us how many fish are in that size-group.
# We want one row for each observation! So we need to repeat that observation by n2.
dat <- dat[rep(seq(nrow(dat)), dat$n2),]
head(dat, 50)

# Test it is correct:
df %>%
  filter(year == 2003 & week == 19 & day == 4 & Stations_namn == "Malören") %>% 
  arrange(n) %>% 
  as.data.frame()

dat %>%
  filter(year == 2003 & week == 19 & day == 4 & Stations_namn == "Malören") %>% 
  arrange(n) %>% 
  dplyr::select(-YtTmp.I, -YtTmp.Upp, -Störning, -TmpBtnU, -Sektion_namn, -Sektion,
                -Areanamn, -Position_N, -Position_E, -Provfiske, -Redskap) %>% 
  as.data.frame()

# Remove disturbance
# Disturbance codes:
# 2: seals damage 
# 3: Strong algal growth on the gears
# 4: Clogging by drifting algae.
# 9: Other reason. (Damage by boat traffic, other human inference etc.)

# Plot disturbance
dat %>% 
  filter(Störning > 1) %>% 
  ggplot(., aes(x = Störning)) +
  geom_histogram(bins = 10) +
  scale_x_continuous(breaks = c(2, 3, 4, 9))

dat <- dat %>% filter(Störning == 0)

# Overfishing effect:
# They put nets many days in a row to get an overfishing affect.
# Catches decline after a few days. I don't want this effect!
# Here we plot which days are fished (fill) over the week that has been fished (x-axis). "Overfishing" effect
# could happen if a year is fished a lot in many consecutive days. It's not clear here that is the case

# Full data
ggplot(dat, aes(factor(week), fill = factor(day))) +
  facet_wrap(~year, scales = "free") +
  geom_bar() 

# Filter autumn
dat %>% 
  filter(week > 35) %>% 
  ggplot(., aes(factor(week), fill = factor(day))) +
  facet_wrap(~year, scales = "free_y") +
  geom_bar()

# Ok, 1984 is heavily fished all year actually.
# We'll remove it since it's very different from the rest. When that is removed, we
# can use Malin's for loop to select fishing days after .v40 (or any other week).
# The other two years with fishing before v.40 are 1996 & 2003, but that's w. 30 so we
# don't belive it has a big effect.

dat <- dat %>% filter(year > 1986)

# In some years they have been fishing almost every week. To not have an
# overfishing-effect, we use only the first part of the fishing that season (first
# day and first week)

# Filter autumn fishing
# By filtering week > 40 & week < 49 I know that I include all October fishing trips
dat_oct <- dat %>%
  filter(week > 40 & week < 49) # OCTOBER

sort(unique(dat_oct$year))
sort(unique(dat_oct$week)) 
# Since this gives me v. 41 42 43 44 45 46 47 
# year -99 -00 is lost due to disturbance

# How does the filtered data set look?
ggplot(dat_oct, aes(x = factor(week), fill = factor(day))) +
  facet_wrap(~year) +
  geom_bar() +
  scale_fill_brewer(palette="Set1", name = "Weekday") +
  theme_classic(base_size = 12) +
  ggtitle("Biotest lake")

# Rename data
catch_BT <- dat_oct
```

## Merge areas and standardize length codes!
```{r merge areas and standardize}
# Clean data to make more readable
catch_BT <- catch_BT %>%
  select(Area, Sektion, Station, year, week, day, length_group, Station,
         Längdgr_std, length_group) %>% 
  as.data.frame()

catch_FM <- catch_FM %>%
  select(Area, Sektion, Station, year, week, day, length_group, Station,
         Längdgr_std, length_group) %>% 
  as.data.frame()

catch <- rbind(catch_BT, catch_FM)

# First split up the data i two separate dataframes, one with std 2 and one with std 3.
# Call them dat_std2 och dat_std3
dat_std2 <- catch %>%
  filter(Längdgr_std == 2)

dat_std3 <- catch %>%
  filter(Längdgr_std == 3)

# Convert std 3 to std 2
sort(unique(dat_std3$length_group))
# 7 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
# 36 37 38 39 40 41 42 43 44 45 46 47

# Insert new column 
dat_std3$length_group2 <- NA
dat_std3$length_group2[dat_std3$length_group==7] <- 6
dat_std3$length_group2[dat_std3$length_group==9] <- 9
dat_std3$length_group2[dat_std3$length_group==10] <- 9
dat_std3$length_group2[dat_std3$length_group==11] <- 11
dat_std3$length_group2[dat_std3$length_group==12] <- 11
dat_std3$length_group2[dat_std3$length_group==13] <- 11
dat_std3$length_group2[dat_std3$length_group==14] <- 14
dat_std3$length_group2[dat_std3$length_group==15] <- 14
dat_std3$length_group2[dat_std3$length_group==16] <- 16
dat_std3$length_group2[dat_std3$length_group==17] <- 16
dat_std3$length_group2[dat_std3$length_group==18] <- 16
dat_std3$length_group2[dat_std3$length_group==19] <- 19
dat_std3$length_group2[dat_std3$length_group==20] <- 19
dat_std3$length_group2[dat_std3$length_group==21] <- 21
dat_std3$length_group2[dat_std3$length_group==22] <- 21
dat_std3$length_group2[dat_std3$length_group==23] <- 21
dat_std3$length_group2[dat_std3$length_group==24] <- 24
dat_std3$length_group2[dat_std3$length_group==25] <- 24
dat_std3$length_group2[dat_std3$length_group==26] <- 26
dat_std3$length_group2[dat_std3$length_group==27] <- 26
dat_std3$length_group2[dat_std3$length_group==28] <- 26
dat_std3$length_group2[dat_std3$length_group==29] <- 29
dat_std3$length_group2[dat_std3$length_group==30] <- 29
dat_std3$length_group2[dat_std3$length_group==31] <- 31
dat_std3$length_group2[dat_std3$length_group==32] <- 31
dat_std3$length_group2[dat_std3$length_group==33] <- 31
dat_std3$length_group2[dat_std3$length_group==34] <- 34
dat_std3$length_group2[dat_std3$length_group==35] <- 34
dat_std3$length_group2[dat_std3$length_group==36] <- 36
dat_std3$length_group2[dat_std3$length_group==37] <- 36
dat_std3$length_group2[dat_std3$length_group==38] <- 36
dat_std3$length_group2[dat_std3$length_group==39] <- 39
dat_std3$length_group2[dat_std3$length_group==40] <- 39
dat_std3$length_group2[dat_std3$length_group==41] <- 41
dat_std3$length_group2[dat_std3$length_group==42] <- 41
dat_std3$length_group2[dat_std3$length_group==43] <- 41
dat_std3$length_group2[dat_std3$length_group==44] <- 44
dat_std3$length_group2[dat_std3$length_group==45] <- 44
dat_std3$length_group2[dat_std3$length_group==46] <- 46
dat_std3$length_group2[dat_std3$length_group==47] <- 46
dat_std3$length_group2[dat_std3$length_group==48] <- 46

# Now compare actual values - Looks ok!
ggplot(dat_std3, aes(factor(length_group), factor(length_group2))) +
  geom_point(size = 2) 

# Remove length_group so that only std 2 is included
dat_std3 <- dat_std3 %>%
  select(-c(length_group))

# Rename length_group2 to length_group
dat_std3 <- dat_std3 %>%
  dplyr::rename(length_group = length_group2)

# Merge data frames
catch_full <- rbind(dat_std2, dat_std3)

# In order to get even length classes (with respect to the code) I gave a new code to std 2
# which represents the starting length in each interval, as opposed to the original
# which was the integer in the middle of 2.5 cm classes...
# E.g. if the interval is 37.6 - 40, the new code becomes 37.6.

sort(unique(catch_full$length_group))
# 6  9 11 14 16 19 21 24 26 29 31 34 36 39 41 44 46

# Insert new column 
catch_full$new_length_group <- NA
catch_full$new_length_group[catch_full$length_group==6] <- 5.1
catch_full$new_length_group[catch_full$length_group==9] <- 7.6
catch_full$new_length_group[catch_full$length_group==11] <- 10.1
catch_full$new_length_group[catch_full$length_group==14] <- 12.6
catch_full$new_length_group[catch_full$length_group==16] <- 15.1
catch_full$new_length_group[catch_full$length_group==19] <- 17.6
catch_full$new_length_group[catch_full$length_group==21] <- 20.1
catch_full$new_length_group[catch_full$length_group==24] <- 22.6
catch_full$new_length_group[catch_full$length_group==26] <- 25.1
catch_full$new_length_group[catch_full$length_group==29] <- 27.6
catch_full$new_length_group[catch_full$length_group==31] <- 30.1
catch_full$new_length_group[catch_full$length_group==34] <- 32.6
catch_full$new_length_group[catch_full$length_group==36] <- 35.1
catch_full$new_length_group[catch_full$length_group==39] <- 37.6
catch_full$new_length_group[catch_full$length_group==41] <- 40.1
catch_full$new_length_group[catch_full$length_group==44] <- 42.6
catch_full$new_length_group[catch_full$length_group==46] <- 45.1

# Compare values
ggplot(catch_full, aes(length_group, new_length_group)) +
  geom_point(size = 2) +
  geom_abline(slope = 1, intercept = 0, color = "red")

# Remove length_group so that only new_length_group is included
catch_full <- catch_full %>%
  select(-c(length_group))

# Rename length_group2 to length_group
catch_full <- catch_full %>%
  dplyr::rename(length_group = new_length_group)

# Insert netID
sort(unique(catch_full$Station))


t <- catch_full %>% 
  dplyr::select(Area, year, week, day, Sektion, Station)

unique(is.na(t))

catch_full$netID <- paste(catch_full$Area, catch_full$year, catch_full$Station, sep = ".")
catch_full$netID2 <- paste(catch_full$Area, catch_full$year, catch_full$week, catch_full$day, catch_full$Sektion, catch_full$Station, sep = ".")

length(unique(catch_full$netID))
```

Save data
```{r save data}
write.csv(catch_full, "data/cleaned/catch_BT_FM_1987-2003.csv", row.names = FALSE)
```

